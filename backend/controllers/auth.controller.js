import { transporter } from "../configs/mailer.js";
import Account from "../models/account.model.js";
import Chapter from "../models/chapter.model.js";
import Member from "../models/member.model.js";
import Notification from "../models/notification.model.js";
import { accountFields, memberFields } from "../utils/field.js";
import { comparePassword, hashPassword } from "../utils/hash.js";
import { regexValidators } from "../utils/regex.js";
import { sendResponse } from "../utils/response.js";
import { getIO } from "../utils/socket.js";
import { signToken, verifyToken } from "../utils/token.js";

const AuthController = () => {
  const register = async (req, res) => {
    try {
      const { token } = req.query;
      const form = req.body;
      console.log(form);
      if (!token) {
        const { account, roleInfo } = form;

        //checkDuplicatedAccount
        console.log(account.password);
        const duplicatedEmail = await Account.findOne({
          email: form.account.email,
        });
        if (duplicatedEmail) {
          return sendResponse(res, 400, "Email n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.");
        }

        for (const field of accountFields) {
          if (!account[field]) {
            return sendResponse(res, 400, `${field} kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng`);
          }

          if (
            regexValidators[field] &&
            !regexValidators[field].test(account[field])
          ) {
            return sendResponse(res, 400, `${field} kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng`);
          }
        }

        if (account.role == "member") {
          //checkDuplicatedCardCode
          const duplicatedCardCode = await Member.findOne({
            cardCode: roleInfo.cardCode,
          });
          if (duplicatedCardCode) {
            return sendResponse(res, 400, "S·ªë th·∫ª ƒëo√†n n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.");
          }

          //checkRoleInfo
          for (const field of memberFields) {
            if (!roleInfo[field]) {
              return sendResponse(res, 400, `${field} kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng`);
            }

            if (
              regexValidators[field] &&
              !regexValidators[field].test(roleInfo[field])
            ) {
              return sendResponse(res, 400, `${field} kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng`);
            }
          }
        }

        if (account.role == "manager") {
          const duplicatedManagerOf = await Account.findOne({
            managerOf: roleInfo.managerOf,
          });
          if (duplicatedManagerOf) {
            return sendResponse(res, 400, "Chi ƒëo√†n n√†y ƒë√£ c√≥ ng∆∞·ªùi qu·∫£n l√Ω.");
          }
        }

        //hashPassword
        account.password = await hashPassword(account.password);
        const confirm = signToken(form);
        await transporter.sendMail({
          from: '"·ª®ng d·ª•ng QLDV" <your_email@gmail.com>',
          to: account.email,
          subject: "X√°c nh·∫≠n t√†i kho·∫£n QLDV",
          html: `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; padding: 20px; border-radius: 8px;">
      <h2 style="color: #2c3e50;">üëã Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ·ª®ng d·ª•ng QLDV!</h2>
      <p style="font-size: 16px; color: #333;">
        C·∫£m ∆°n b·∫°n ƒë√£ ƒëƒÉng k√Ω. Vui l√≤ng nh·∫•n v√†o n√∫t b√™n d∆∞·ªõi ƒë·ªÉ x√°c nh·∫≠n t√†i kho·∫£n c·ªßa b·∫°n:
      </p>
      <div style="text-align: center; margin: 30px 0;">
        <a href="http://localhost:5000/api/auth/confirm-register/?token=${confirm}" style="background-color: #007BFF; color: white; padding: 12px 20px; text-decoration: none; border-radius: 5px; font-size: 16px;">
          X√°c nh·∫≠n t√†i kho·∫£n
        </a>
      </div>
      <p style="font-size: 14px; color: #777;">
        N·∫øu b·∫°n kh√¥ng ƒëƒÉng k√Ω t√†i kho·∫£n, vui l√≤ng b·ªè qua email n√†y.
      </p>
      <hr style="margin: 20px 0;">
      <p style="font-size: 12px; color: #aaa;">·ª®ng d·ª•ng QLDV ¬© 2025</p>
    </div>
  `,
        });

        return sendResponse(res, 200, "H√£y ki·ªÉm tra email c·ªßa b·∫°n");
      }

      const decode = verifyToken(token);
      const { account, roleInfo } = decode;
      console.log(account);
      const accountdb = new Account(account);
      if (account.role == "member") {
        var memberdb = new Member(roleInfo);
      }
      if (account.role == "manager") {
        accountdb.managerOf = roleInfo.managerOf;
      }

      accountdb.status = "pending";

      console.log(accountdb.password);

      if (memberdb) {
        accountdb.infoMember = memberdb._id;
        await memberdb.save();
      }

      await accountdb.save();

      const admin = await Account.findOne({ role: "admin" });

      const notification = new Notification({
        accountId: admin._id,
        text: `B·∫°n c√≥ y√™u c·∫ßu ph√™ duy·ªát t·ª´ ${account.fullname}`,
      });

      const io = getIO();
      io.emit("admin_req", `B·∫°n c√≥ y√™u c·∫ßu ph√™ duy·ªát t·ª´ ${account.fullname}`);
      await notification.save();

      res.redirect(301, "http://localhost:5173/"); // redirect vƒ©nh vi·ªÖn
    } catch (error) {
      console.log(error);
      return sendResponse(res, 500, "L·ªói ƒëƒÉng k√Ω. H√£y th·ª≠ l·∫°i");
    }
  };

  const login = async (req, res) => {
    try {
      const { email, password } = req.body;


      const account = await Account.findOne({ email: email }).populate(
        "infoMember"
      );
      if (!account) {
        return sendResponse(
          res,
          404,
          "L·ªói ƒëƒÉng nh·∫≠p. Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n"
        );
      }

      if (!(await comparePassword(password, account.password))) {
        return sendResponse(res, 404, "L·ªói ƒëƒÉng nh·∫≠p. M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng");
      }
      const chapterId =
        account.managerOf || account.infoMember?.memberOf || null;
      const chapter = await Chapter.findById(chapterId);
      if (
        account.status != "active" ||
        (chapter && chapter.status != "active")
      ) {
        return sendResponse(res, 403, "B·∫°n ch∆∞a c√≥ quy·ªÅn truy c·∫≠p");
      }

      const token = signToken({ accountId: account._id });

      return sendResponse(res, 200, "ƒêƒÉng nh·∫≠p th√†nh c√¥ng", {
        token,
        role: account.role,
      });
    } catch (error) {
      console.log(error);
      return sendResponse(res, 500, "L·ªói ƒëƒÉng nh·∫≠p. H√£y th·ª≠ l·∫°i");
    }
  };
  // // H√†m ƒëƒÉng nh·∫≠p
  // const login = async (req, res) => {
  //   const logPrefix = "[AuthController][login]";
  //   console.log(`${logPrefix} Start with data:`, req.body);

  //   try {
  //     const input = req.body;

  //     // T√¨m t√†i kho·∫£n theo email
  //     const account = await Account.findOne({ email: input.email })
  //       .select("+password")
  //       .populate("infoMember")
  //       .populate("managerOf");

  //     if (!account) {
  //       return response(res, 401, "INVALID_CREDENTIALS");
  //     }

  //     // So s√°nh m·∫≠t kh·∫©u nh·∫≠p v√†o v·ªõi m·∫≠t kh·∫©u ƒë√£ l∆∞u (ƒë√£ m√£ h√≥a)
  //     const isMatch = bcrypt.compare(input.password, account.password);
  //     if (!isMatch) {
  //       return response(res, 401, "INVALID_CREDENTIALS");
  //     }

  //     // Ki·ªÉm tra tr·∫°ng th√°i t√†i kho·∫£n v√† member (n·∫øu c√≥)
  //     if (
  //       account.status === "waiting" || account.status === "banned" ||
  //       (account.infoMember && (account.infoMember.status === "waiting" || account.infoMember.status === "banned")) ||
  //       (account.managerOf && account.managerOf.status === "banned")
  //     ) {
  //       return response(res, 401, "INVALID_ACCOUNT_STATUS");
  //     }

  //     // Sinh token x√°c th·ª±c
  //     const token = generateToken(account);
  //     res.cookie("token", token, { httpOnly: false });

  //     return response(res, 200, "LOGIN_SUCCESS", { token, role:account.role });
  //   } catch (error) {
  //     console.error(`${logPrefix} Error:`, error);
  //     return response(res, 500, "SERVER_ERROR");
  //   }
  // };

  // // H√†m ƒëƒÉng xu·∫•t
  // const logout = async (req, res) => {
  //   const logPrefix = "[AuthController][logout]";
  //   console.log(`${logPrefix} Start for account:`, req.accountId);

  //   try {
  //     res.clearCookie("token", { httpOnly: true });
  //     return response(res, 200, "LOGOUT_SUCCESS");
  //   } catch (error) {
  //     console.error(`${logPrefix} Error:`, error);
  //     return response(res, 500, "SERVER_ERROR");
  //   }
  // };

  // // H√†m l·∫•y th√¥ng tin h·ªì s∆° c√° nh√¢n
  // const getProfile = async (req, res) => {
  //   const logPrefix = "[AuthController][getProfile]";
  //   const decode = verifyToken(req.cookies.token);
  //   const accountId = decode.id;

  //   try {
  //     const account = await Account.findById(accountId)
  //       .populate("infoMember")
  //       .populate("managerOf");

  //     return response(res, 200, "PROFILE_FETCHED", account);
  //   } catch (error) {
  //     console.error(`${logPrefix} Error:`, error);
  //     return response(res, 500, "SERVER_ERROR");
  //   }
  // };

  // // H√†m c·∫≠p nh·∫≠t h·ªì s∆° c√° nh√¢n
  // const updateProfile = async (req, res) => {
  //   const logPrefix = "[AuthController][updateProfile]";
  //   const decode = verifyToken(req.cookies.token);
  //   const accountId = decode.id;

  //   try {
  //     const input = req.body;
  //     const file = req.file;

  //     const currentAccount = await Account.findById(accountId);
  //     const accountFields = ["email", "phone", "fullname", "birthday", "gender", "role"];

  //     // Ki·ªÉm tra email m·ªõi c√≥ tr√πng kh√¥ng
  //     if (input.email !== "") {
  //       const existingAccount = await Account.findOne({ email: input.email });
  //       if (existingAccount && existingAccount._id.toString() !== accountId.toString()) {
  //         return response(res, 400, "INVALID_ACCOUNT_DATA");
  //       }
  //     }

  //     // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng th√¥ng tin c·ªßa t√†i kho·∫£n
  //     for (const field of accountFields) {
  //       if (input[field] !== "") {
  //         currentAccount[field] = input[field];
  //       }
  //     }

  //     // C·∫≠p nh·∫≠t avatar n·∫øu c√≥
  //     if (input.avatar !== "") {
  //       currentAccount.avatar = file.path;
  //     }

  //     // N·∫øu l√† member, c·∫≠p nh·∫≠t infoMember
  //     if (currentAccount.infoMember) {
  //       const currentMember = await Member.findById(currentAccount.infoMember);
  //       const infoMemberFields = [
  //         "chapterId", "cardId", "position", "joinedAt",
  //         "address", "hometown", "ethnicity", "religion", "eduLevel",
  //       ];

  //       if (input.cardId !== "") {
  //         const existingMember = await Member.findOne({ cardId: input.cardId });
  //         if (existingMember && currentMember._id.toString() !== existingMember._id.toString()) {
  //           return response(res, 400, "INVALID_MEMBER_DATA");
  //         }
  //       }

  //       for (const field of infoMemberFields) {
  //         if (input[field] !== "") {
  //           currentMember[field] = input[field];
  //         }
  //       }

  //       await currentMember.save();
  //     }

  //     // N·∫øu l√† manager, c·∫≠p nh·∫≠t chapter ph·ª• tr√°ch
  //     if (currentAccount.managerOf && input.chapterId !== "") {
  //       currentAccount.managerOf = input.chapterId;
  //     }

  //     await currentAccount.save();

  //     // Tr·∫£ v·ªÅ t√†i kho·∫£n ƒë√£ c·∫≠p nh·∫≠t
  //     const updatedAccount = await Account.findById(accountId)
  //       .populate("infoMember")
  //       .populate("managerOf");

  //     return response(res, 201, "ACCOUNT_UPDATED", updatedAccount);
  //   } catch (error) {
  //     console.error(`${logPrefix} Error:`, error);
  //     return response(res, 500, "SERVER_ERROR");
  //   }
  // };
  const getProfile = async (req, res) => {
    try {
      const account = await Account.findById(req.account._id);
      return sendResponse(res, 200, "L·∫•y h·ªì s∆° th√†nh c√¥ng", account);
    } catch (error) {
      console.log(error);
      return sendResponse(res, 500, "L·ªói l·∫•y h·ªì s∆°, h√£y th·ª≠ l·∫°i");
    }
  };
  return {
    register,
    login,
    // logout,
    getProfile,
    // updateProfile,
  };
};

export default AuthController();
